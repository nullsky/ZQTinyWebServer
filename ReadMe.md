# TinyWebServer
Linux下C++轻量级Web服务器，助力初学者快速实践网络编程，搭建属于自己的服务器.

写在前面
-----------
- TinyWebServer项目是游双大佬写的GitHub开源项目，本着学习的目的，照葫芦画瓢。
- 本项目打算从底层开始实现，自底向上进行，逐步完善。

## 一、lock
### 1.1 信号量
```c++
int sem_init(sem_t *sem,int pshared,unsigned int value); 
```
初始化一个定位在sem的匿名信号量；value是信号量的初始值；pshared=0，该信号量用
于进程间的线程共享，pshared>0，用于进程间共享。

返回值：0-创建成功，-1-创建失败。

```c++
int semget(key_t key, int nsems, int semflg);
```
用于进程间通信，取得信号量
key：键值，该键值对应一个唯一的信号量。类似于共享内存的键值。
不同的进程可通过该键值和semget获取唯一的信号量

特殊键值：
IPC_PRIVAT该信号量只允许创建者本身， 可用于父子进程间通信。
### 1.2 条件变量
也可用于进程间通信
- wait:等待条件，等待开始时，会自动释放掉mutex；条件成立，会自动加锁。
- signal：发出条件满足信号
- broadcast:广播信号
### 1.3 生产者-消费者模型
通过维护一个队列，利用锁和条件变量，来完成共享内存的访问。
### 1.4 死锁
## 二、日志 
- 同步日志
- 异步日志
- 日志等级
- 单例模式
- 按天数、超行分类
## 三、数据库连接池
- 连接池维护一堆事先创建好的sql连接，每次从连接池中拿出可用连接，用完放回去
- list维护连接池
- 通过RAII实现MYSQL资源的释放
- 通过信号量，实现生产者-消费者的模式，访问连接池

## 四、线程池
### 4.1 服务器编程基本框架
主要由I/O单元，逻辑单元和网络存储单元组成，其中每个单元之间通过请求队列进行通信，从而协同完成任务。
### 4.2 五种I/O模型
- 阻塞IO
- 非阻塞IO
- 信号驱动IO
- IO复用
- 异步IO
注意：阻塞IO、非阻塞IO、信号驱动IO和IO复用都是同步IO。
- 同步IO：指内核向应用程序通知的是就绪事件
- 异步IO：指内核向应用程序通知的是完成事件
### 4.3 事件处理模式
**reactor模式**
> 主线程(I/O处理单元)只负责监听文件描述符上是否有事件发生，有的话立即通知工作线程(逻辑单元 )，读写数据、接受新连接及处理客户请求均在工作线程中完成。通常由同步I/O实现。

**proactor模式**
> 主线程和内核负责处理读写数据、接受新连接等I/O操作，工作线程仅负责业务逻辑，如处理客户请求。通常由异步I/O实现

